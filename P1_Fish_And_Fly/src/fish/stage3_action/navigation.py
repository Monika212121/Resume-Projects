# NOTE (v1 MVP):
# Underwater path is generated by reversing surface coverage.
# This will be replaced by depth-aware and flow-aware planning in later versions.

import math
from typing import List, Dict, Any

from src.common.logging import logger
from src.common.visualization.world_projection import WorldObject

from src.fish.stage3_action.entity import Waypoint, Navigation, Speeds



class PathNavigator:
    """
    Helps in Fish's machine navigation. 
    """
    def __init__(self, navigation_cfg: Navigation):
        self.navigation_cfg = navigation_cfg
        self.speeds: Speeds  = navigation_cfg.speeds
        self.curr_speed: float = self.speeds.surface

        self.path: List[Waypoint] = []
        self.dt = 0.1
        self.current_index: int = 0                                                  # No. of waypoints crossed in the set path.
        self.current_position: Waypoint = navigation_cfg.start_point
        self.sweep_step: float = navigation_cfg.sweep_step

        self.reach_threshold: float = self.curr_speed * self.dt * 0.5                # avoid overshoot
        self.threshold: float = 0.08                                                 # to check relative distance between fish and target object.
        self.paused: bool = False

        self.trajectory: list[Dict[Any, Any]] = []
        self.step_count: int = 0


    def set_path(self, depth: float, start_position: Waypoint):
        try:
            logger.info(f"PathNavigator -> set_path(): STARTS, depth: {depth}")

            # Generate SURFACE path once.
            if not self.path or len(self.path) == 0:
                self.path = self.generate_lawnmower_path(cleaning_depth = 0.0)

            # NOTE: UNDERWATER path = Reversed cached SURFACE path + project to depth.
            # SURFACE LEVEL path is generted first, then UNDERWATER LEVEL.
            if depth < 0:
                rev_surface_path = list(reversed(self.path)) 
                active_path = [Waypoint(wp.x, wp.y, depth) for wp in rev_surface_path]                                       
            else:
                active_path = self.path
             
            # Updating path parameters for the current operation level.
            self.path = active_path
            self.current_position = start_position
            self.current_index = 0                                                      # to avoid index error if path is not generated.
            self.paused = False

            logger.info(f"PathNavigator -> set_path(): ENDS, active path: {self.path}")
            return 


        except Exception as e:
            logger.info(f"Error occurred in PathNavigator -> set_path(), error: {e}")
            raise e




    def generate_lawnmower_path(self, cleaning_depth: float) -> List[Waypoint]:
        """
        Generates the `Lawn mower path` pattern, the chosen navigation pattern for the Fish machine.

        ONLY generates surface-style lawnmower path.
        ```
            [----------------                  
            ----------------]
            [----------------                  
            ----------------]
            [----------------                  
            ----------------]
            [----------------                  
            ----------------]

            (brackets are turns)
        ```
        
        :param self: Belongs to the PathNavigator class.
        :param cleaning_depth: Depth of workspace of current operation. 
        :type cleaning_depth: float
        :return: List of waypoint in the Lawn-mower path.
        :rtype: List[Waypoint]
        """
        try:
            logger.info(f"PathNavigator -> generate_lawn_mower_path(): STARTS, cleaning_depth: {cleaning_depth}")
            
            path: List[Waypoint] = []

            # Defining boundary of workspace.
            x_start, y_start = self.navigation_cfg.start_point.x, self.navigation_cfg.start_point.y
            x_end, y_end = self.navigation_cfg.end_point.x, self.navigation_cfg.end_point.y

            direction: int = 1
            y_curr: float = y_start

            while y_curr <= y_end:              # (eg: 0 < 100, 20 < 100, 100 = 100)
                # Moving forward in x-axis
                if direction == 1:                                              
                    path.append(Waypoint(x_start, y_curr, cleaning_depth))      # x -> 0,       y -> 0
                    path.append(Waypoint(x_end, y_curr, cleaning_depth))        # x -> 100,     y -> 0

                # Moving backward in x-axis
                else:                                                           
                    path.append(Waypoint(x_end, y_curr, cleaning_depth))        # x -> 100,     y -> 5
                    path.append(Waypoint(x_start, y_curr, cleaning_depth))      # x -> 0,       y -> 5

                # Moving in y-axis, by 1 sweep step, to reach towards end point.
                y_curr += self.sweep_step    

                # Reversing the direction of fish machine.   
                direction *= -1                 
                

            logger.info(f"PathNavigator -> generate_lawn_mower_path(): ENDS")
            return path


        except Exception as e:
            logger.info(f"Error occurred in PathNavigator -> generate_lawnmower_path(), error: {e}")
            raise e



    def pause(self):
        self.paused = True

    
    def resume(self):
        self.paused = False



    def step(self, dt: float = 1.0) -> bool:
        try:
            logger.info(f"PathNavigator -> step(): STARTS")

            # 1. Guard conditions
            if self.paused or self.path_is_finished():
                logger.info(f"PathNavigator -> step(): Step cannot be taken now, reason is: pause-> {self.paused} or path_finished-> {self.path_is_finished()}")
                return False
            
            # for trajectory logging
            self.step_count += 1

            # 2. Recognize the next target waypoint in the set path.
            logger.info(f"PathNavigator -> step(), current index: {self.current_index}")
            target_waypoint = self.path[self.current_index]
            curr_pos = self.current_position
            logger.info(f"PathNavigator -> step(), current position: {self.current_position}, target: {target_waypoint}")

            # 3. Calculate direction vectors (3D)
            dx = target_waypoint.x - curr_pos.x
            dy = target_waypoint.y - curr_pos.y
            dz = target_waypoint.z - curr_pos.z

            distance = math.sqrt(dx*dx + dy*dy + dz*dz)
            logger.info(f"distance btw curr and tar: {distance}")

            # 4. If already exactly at target waypoint
            if distance == 0.0:
                self.current_index += 1
                logger.info(f"PathNavigator -> step(): Already at waypoint, advancing index.")
                target_waypoint = self.path[self.current_index]             # set the next waypoint in the path as target.

                # Calculate direction vectors (3D) again.
                dx = target_waypoint.x - curr_pos.x
                dy = target_waypoint.y - curr_pos.y
                dz = target_waypoint.z - curr_pos.z

                distance = math.sqrt(dx*dx + dy*dy + dz*dz)
                logger.info(f"new distance btw curr and tar: {distance}")

            # 5. Compute step distance, using formula `distance = speed * time`
            step_distance = self.curr_speed * dt

            # 6. Check if close enough or will overshoot -> Snap to target waypoint.
            if distance <= self.reach_threshold or distance <= step_distance:
                self.current_position = target_waypoint                     # snap to waypoint first
                self.current_index += 1                                     # update the target to next waypoint
                logger.info(f"PathNavigator -> step(): reached target, snapping to {self.current_position}")
                return True

            # 7. Normalize directions
            ux = dx / distance
            uy = dy / distance
            uz = dz / distance

            # 8. Incremental motion
            new_x = curr_pos.x + ux * step_distance
            new_y = curr_pos.y + uy * step_distance
            new_z = curr_pos.z + uz * step_distance

            self.current_position = Waypoint(new_x, new_y, new_z)

            self._log_trajectory_point()
            logger.info(f"PathNavigator -> step(): ENDS, incremented to new_position: {self.current_position}")
            return True

        
        except Exception as e:
            logger.info(f"Error occurred in PathNavigator -> step(), error: {e}")
            raise e


    def path_is_finished(self) -> bool:
        try:
            logger.info(f"PathNavigator -> path_is_finished()")
            return self.current_index >= len(self.path)
        
        except Exception as e:
            logger.info(f"Error occurred in PathNavigator -> path_is_finished(), error: {e}")
            raise e


    def target_is_near(self, world_obj: WorldObject) -> bool:
        """
        Decide if target is close enough to execute manipulation.
        """
        try:
            logger.info(f"PathNavigator -> target_is_near(), world object: {world_obj}")
            return world_obj.distance <= self.threshold
        
        except Exception as e:
            logger.info(f"Error occurred in PathNavigator -> target_is_near(), error: {e}")
            raise e
    


    def move_to(self, target_point: Waypoint) -> bool:
        try:
            logger.info(f"PathNavigator -> move_to(): STARTS, current postion: {self.current_position}")
            # TODO: Placeholder for simulation / real control.
            
            self.current_position = target_point

            logger.info(f"PathNavigator -> move_to(): ENDS, final position: {self.current_position}")
            return True

    
        except Exception as e:
            logger.info(f"Error occurred in PathNavigator -> move_to(), error: {e}")
            raise e   
        


    # NOTE: Can be refactored into TrajectoryLogger service in future
    def _log_trajectory_point(self):
        try:
            logger.info(f"PathNavigator -> log_trajectory_point(): STARTS")

            operation_level = "surface" if self.current_position.z >= 0 else "underwater"

            self.trajectory.append({
                "x": self.current_position.x,
                "y": self.current_position.y,
                "z": self.current_position.z,
                "operation_level": operation_level,
                "step_taken": self.step_count
            })


        except Exception as e:
            logger.info(f"Error occurred in PathNavigator -> log_trajectory_point(), error: {e}")
            raise e




    """
    def target_is_near(self, target_bbox: Tuple[int, int, int, int]) -> bool:
        tx, ty = target_bbox[0], target_bbox[1]
        cx, cy = self.current_position.x, self.current_position.y

        target_dis = math.hypot(tx - cx, ty - cy)
        
        logger.info(f"PathNavigator -> target_is_near(): ENDS, target_distance: {target_dis}")

        return target_dis < self.reach_threshold
    """